Semaphore S(k)

//k >= 1 threads

void DFSSignaturesExploration(int depth, int* answer, int* fork_depth, params) {
    if (*answer) {
        return;
    }

    //some code

    for (size_t i = 0; i < neigh.size(); ++i) {
        if (i + 1 < neigh.size() && depth >= *(fork_depth)) {
            if (S.Lock()) {
                if ((ret = fork()) != -1) {
                    if (ret) {
                        //master, wait for all forks and then take the last sub-tree
                    } else {
                        DFSSignaturesExploration(1, answer, fork_depth);
                    }
                } else {
                    cerr << "Couldn't fork" << endl;
                    DFSSignaturesExploration(depth + 1, answer, fork_depth);
                }

                S.Release();
            } else {
                DFSSignaturesExploration(depth + 1, answer, fork_depth);
            }
        } else {
            fork_depth = max(fork_depth, depth + 1);
            DFSSignaturesExploration(depth + 1, answer, fork_depth);
        }
    }
}

sh_mem int answer = 0;
sh_mem int fork_depth = 0;

for (size_t i = 0; i < startEdges.size(); ++i) {
    if (i + 1 < startEdges.size()) {
        if (S.Lock()) {
            if ((ret = fork()) != -1) {
                if (ret) {
                    //master, wait for all forks and then take the last sub-tree
                } else {
                    DFSSignaturesExploration(1, answer, fork_depth);
                }
            } else {
                cerr << "Couldn't fork" << endl;
                DFSSignaturesExploration(1, answer, fork_depth);
            }

            S.Release();
        } else {
            DFSSignaturesExploration(1, answer, fork_depth);
        }
    } else {
        fork_depth = 1;
        DFSSignaturesExploration(1, answer, fork_depth);
    }
}
